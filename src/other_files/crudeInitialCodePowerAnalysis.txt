# Function to detect contaminated epochs in the child channels
#def detectContaminatedChildEpochs(power45_70Hz, channelNames, threshold):
	
#	childEpochs = np.zeros((len(channelNames), 100), dtype='int')
#	for i in range(len(channelNames)):
#		if power45_70Hz[i, 0] > threshold:
#			childEpochs[i, 0] = -1
#		for epoch in range(1,100):
#			if power45_70Hz[i, epoch] > threshold:
#				childEpochs[i, epoch] = epoch

#	return childEpochs

# Function to detect the contaminated data from contaminated channels and epochs
#def detectContaminatedData(data, channelNames, channelEpochs):
#	contaminatedData = np.zeros((len(channelNames),100,1024),dtype='float')

#	for i in range(len(channelNames)):
#		if channelEpochs[i,0] == -1:
#			contaminatedData[i,0,:] = data[i, 1:1024+1]
#		for epoch in range(1, 100):
#			if channelEpochs[i,epoch]!= 0:
#				contaminatedData[i,epoch,:] = data[i, (1024*epoch)+1:(1024*(epoch+1))+1]
#	return contaminatedData


# Hash map/Dictionary


				
				
			
				


#Global function for identification of EMG artifacts by 
#power analysis in the 45-70Hz freuquency band.
#def identifyArtifacts(raw):
#	# Declaring the channel names variable for the analysis
#	channelNamesPrimary = ['AF7','AF8','FT7','FT8']
#	channelNamesAf7 = ['Fp1', 'AF3', 'F3', 'F5', 'F7']
#	channelNamesAf8 = ['Fp2', 'AF4', 'F4', 'F6', 'F8']
#	channelNamesFt7 = ['F7', 'F5', 'FC5', 'C5', 'T7']
#	channelNamesFt8 = ['F8', 'F6', 'FC6', 'C6', 'T8']
#	channelNamesFz = ['Fz']
	
#	# Calling the bandpower function to calculate power and return data of channels
#	powerPrimary, primaryData = bandPower(raw, channelNamesPrimary)
#	af7Power45_70Hz, af7Data = bandPower(raw, channelNamesAf7)
#	af8Power45_70Hz, af8Data = bandPower(raw, channelNamesAf8)
#	ft7Power45_70Hz, ft7Data = bandPower(raw, channelNamesFt7)
#	ft8Power45_70Hz, ft8Data = bandPower(raw, channelNamesFt8)
#	fzPower45_70Hz, fzData = bandPower(raw, channelNamesFz)
	
#	#Step 1 :Finding the threshold val without simulated data.
#	#thresholdValPaper = power45_70Hz.mean(axis = 1)+1*power45_70Hz.std(axis = 1) 
#	threshold_val = powerPrimary.mean(axis = 1)
#	# Detecting the contaminated epochs

#	primaryEpochs = detectContaminatedEpochs(powerPrimary, channelNamesPrimary,
#												 threshold_val)

#	# Will refactor call sequence
#	childEpochsAf7 = detectContaminatedChildEpochs(af7Power45_70Hz,  channelNamesAf7, primaryEpochs, 
#													threshold_val[0])
#	childEpochsAf8 = detectContaminatedChildEpochs(af8Power45_70Hz,  channelNamesAf8, primaryEpochs, 
#													threshold_val[1])
#	childEpochsFt7 = detectContaminatedChildEpochs(ft7Power45_70Hz,  channelNamesFt7, primaryEpochs, 
#													threshold_val[2])
#	childEpochsFt8 = detectContaminatedChildEpochs(ft8Power45_70Hz,  channelNamesFt8, primaryEpochs, 
#													threshold_val[3])

	
#	#Storing the primary contaminated data obtained from contaminated epoch indices                
#	primaryContaminatedData = detectContaminatedData(primaryData, channelNamesPrimary, channelEpochsPrimary) 
#	Af7ContaminatedData = detectContaminatedData(af7Data, channelNamesAf7, childEpochsAf7) 
#	Af8ContaminatedData = detectContaminatedData(af8Data, channelNamesAf8, childEpochsAf8) 
#	Ft7ContaminatedData = detectContaminatedData(Ft7Data, channelNamesFt7, childEpochsFt7) 
#	Ft8ContaminatedData = detectContaminatedData(Ft8Data, channelNamesFt8, childEpochsFt8) 
	
	# Getting the channel, epoch and time point indices of the non-zero contaminated data
	channels, epochs, times = np.nonzero(primaryContaminatedData != 0)
	channelsAf7, epochsAf7, timesAf7 = np.nonzero(Af7ContaminatedData != 0)
	
	# Setting the no. of channels and no. of time points 
	n_channels = len(channelNamesPrimary) + len(channelsAf7)
	n_time_points = int(len(times)/n_channels) + int(len(timesAf7)/len(channelsAf7))
	ContaminatedData = np.concatenate((primaryContaminatedData, Af7ContaminatedData), axis =0)
	dataWithArtifactsDetected = ContaminatedData[ContaminatedData != 0].reshape(n_time_points,
																					n_channels)

	
	sampling_rate = raw.info['sfreq']
	info = mne.create_info(ch_names = channelNamesPrimary, sfreq = sampling_rate, ch_types=['eeg']*n_channels)
	dataWithArtifactsDetectedRaw = mne.io.RawArray(dataWithArtifactsDetected.T, info)

#	return dataWithArtifactsDetected, dataWithArtifactsDetectedRaw











##Using simulated data: Will do later
#sim_data_thres = threshold.sim_threshold(raw)

##Step 2 :Finding the channel epoch indices which are greater than threshold
#chan_epoch_indice_primary = np.zeros((len(primary_raw.ch_names),100),dtype='int')

#for chan in range(len(primary_raw.ch_names)):
#	for epoch in range(50):
#		if primary_power_45_70Hz[chan,epoch] > threshold_val:
#			chan_epoch_indice_primary[chan,epoch] = epoch 

#chan_epoch_indices_AF7 = np.zeros((len(AF7_raw.ch_names),50),dtype='int')
#chan_epoch_indices_AF8 = np.zeros((len(AF8_raw.ch_names),50),dtype='int')
#chan_epoch_indices_FT7 = np.zeros((len(FT7_raw.ch_names),50),dtype='int')
#chan_epoch_indices_FT8 = np.zeros((len(FT8_raw.ch_names),50),dtype='int')


#for idx in chan_epoch_indice_primary:
#	if  chan_epoch_indice_primary.any() == 0:
#		for chan in range(len(AF7_raw.ch_names)):
#			for epoch in range(50):
#				if AF7_power_45_70Hz[chan,epoch] >threshold_val[0]:
#					chan_epoch_indices_AF7[chan,epoch] = epoch
#	elif chan_epoch_indice_primary.any() == 1:
#		for chan in range(len(AF8_raw.ch_names)):
#			for epoch in range(50):
#				if AF8_power_45_70Hz[chan,epoch] >threshold_val[1]:
#					chan_epoch_indices_AF8[chan,epoch] = epoch
#	elif chan_epoch_indice_primary.any() == 2:
#		for chan in range(len(FT7_raw.ch_names)):
#			for epoch in range(50):
#				if AF8_power_45_70Hz[chan,epoch] >threshold_val[2]:
#					chan_epoch_indices_FT7[chan,epoch] = epoch
#	elif chan_epoch_indice_primary.any() == 3:
#		for chan in range(len(FT7_raw.ch_names)):
#			for epoch in range(50):
#				if AF8_power_45_70Hz[chan,epoch] >threshold_val[3]:
#					chan_epoch_indices_FT7[chan,epoch] = epoch
#print('thres_mara')
	
				
#Step 2a: Decomposing the power data array in to epochs by power



#Step 3: Locating the channels



#Step 3a: Decomposing the power data array into channels by epochs




#Step 4: Locating the contaminated epochs and finding the corresponding channel indices 
#for shuffling the contaminated data